#!/usr/bin/env python3

"""
Command line utility tool for outputting geometrical information about a platform on a given interval
"""

# pylint: disable=duplicate-code
# pylint: disable=invalid-name

import sys
import time
import json
import logging
import argparse
import warnings
from pathlib import Path

import zenoh
from scipy.spatial.transform import Rotation
from jsonschema import validate, ValidationError
from keelson import construct_pubsub_key, enclose
from keelson.payloads.Primitives_pb2 import TimestampedFloat
from keelson.payloads.foxglove.FrameTransform_pb2 import FrameTransform

logger = logging.getLogger("platform-geometry")

JSON_SCHEMA = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Platform Configuration",
  "description": "Configuration schema for vessel platform geometry and frame transforms",
  "type": "object",
  "required": ["vessel_name", "length_over_all_m", "breadth_over_all_m", "frame_transforms"],
  "properties": {
    "vessel_name": {
      "type": "string",
      "description": "Name identifier for the vessel",
      "minLength": 1
    },
    "length_over_all_m": {
      "type": "number",
      "description": "Length over all in meters",
      "exclusiveMinimum": 0
    },
    "breadth_over_all_m": {
      "type": "number",
      "description": "Breadth over all in meters",
      "exclusiveMinimum": 0
    },
    "frame_transforms": {
      "type": "array",
      "description": "Array of coordinate frame transformations",
      "items": {
        "$ref": "#/definitions/frameTransform"
      },
      "minItems": 0
    }
  },
  "definitions": {
    "frameTransform": {
      "type": "object",
      "required": ["parent_frame_id", "child_frame_id", "translation_m", "rotation_deg"],
      "properties": {
        "parent_frame_id": {
          "type": "string",
          "description": "Identifier for the parent coordinate frame",
          "minLength": 1
        },
        "child_frame_id": {
          "type": "string",
          "description": "Identifier for the child coordinate frame",
          "minLength": 1
        },
        "translation_m": {
          "$ref": "#/definitions/translation",
          "description": "Translation in meters from parent to child frame"
        },
        "rotation_deg": {
          "$ref": "#/definitions/rotation",
          "description": "Rotation in degrees from parent to child frame"
        }
      }
    },
    "translation": {
      "type": "object",
      "required": ["x", "y", "z"],
      "properties": {
        "x": {
          "type": "number",
          "description": "Translation along X-axis in meters"
        },
        "y": {
          "type": "number",
          "description": "Translation along Y-axis in meters"
        },
        "z": {
          "type": "number",
          "description": "Translation along Z-axis in meters"
        }
      },
      "additionalProperties": false
    },
    "rotation": {
      "type": "object",
      "required": ["yaw", "pitch", "roll"],
      "description": "Order of operation YAW --> Pitch --> ROLL",
      "properties": {
        "yaw": {
          "type": "number",
          "description": "Yaw rotation in degrees",
          "minimum": -180,
          "maximum": 180
        },
        "pitch": {
          "type": "number",
          "description": "Pitch rotation in degrees",
          "minimum": -180,
          "maximum": 180
        },
        "roll": {
          "type": "number",
          "description": "Roll rotation in degrees",
          "minimum": -180,
          "maximum": 180
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
"""


def run(session: zenoh.Session, args: argparse.Namespace, config: dict):

    # Set up keys
    key_loa = construct_pubsub_key(
        args.realm,
        args.entity_id,
        "length_over_all_m",
        args.source_id,
    )

    key_boa = construct_pubsub_key(
        args.realm,
        args.entity_id,
        "breadth_over_all_m",
        args.source_id,
    )

    key_frame_transform = construct_pubsub_key(
        args.realm,
        args.entity_id,
        "frame_transform",
        args.source_id,
    )

    # Lets start pushing messages
    while True:

        # Lets give all messages in this iteration the same timestamp
        timestamp = time.time_ns()

        if loa := config.get("length_over_all_m"):
            payload = TimestampedFloat()
            payload.timestamp.FromNanoseconds(timestamp)
            payload.value = loa

            logger.debug("Putting to %s", key_loa)
            session.put(key_loa, enclose(
                payload.SerializeToString(), enclosed_at=timestamp))

        if boa := config.get("breadth_over_all_m"):
            payload = TimestampedFloat()
            payload.timestamp.FromNanoseconds(timestamp)
            payload.value = boa

            logger.debug("Putting to %s", key_boa)
            session.put(key_boa, enclose(
                payload.SerializeToString(), enclosed_at=timestamp))

        for transform in config.get("frame_transforms", []):
            payload = FrameTransform()
            payload.timestamp.FromNanoseconds(timestamp)

            payload.parent_frame_id = transform["parent_frame_id"]
            payload.child_frame_id = transform["child_frame_id"]

            payload.translation.x = transform["translation_m"]["x"]
            payload.translation.y = transform["translation_m"]["y"]
            payload.translation.z = transform["translation_m"]["z"]

            quat = Rotation.from_euler(
                "zyx", [transform["rotation_deg"]["yaw"],transform["rotation_deg"]["pitch"],transform["rotation_deg"]["roll"]], degrees=True).as_quat()

            payload.rotation.x = quat[0]
            payload.rotation.y = quat[1]
            payload.rotation.z = quat[2]
            payload.rotation.w = quat[3]

            logger.debug("Putting to %s", key_frame_transform)
            session.put(key_frame_transform, enclose(
                payload.SerializeToString(), enclosed_at=timestamp))

        time.sleep(args.interval)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="platform-geomtry",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="Command line utility tool for outputting geometrical information about a platform on a given interval"
    )
    parser.add_argument("--log-level", type=int, default=logging.WARNING)
    parser.add_argument(
        "--connect",
        action="append",
        type=str,
        help="Endpoints to connect to.",
    )

    parser.add_argument("-r", "--realm", type=str, required=True)
    parser.add_argument("-e", "--entity-id", type=str, required=True)
    parser.add_argument("-s", "--source-id", type=str, required=True)

    parser.add_argument("--config", type=Path, required=True,
                        help="A path to a JSON-encoded configuration file for this platform.")
    parser.add_argument("--interval", type=int, default=10,
                        help="Interval (second) at whic the information will be put to zenoh.")

    # Parse arguments and start doing our thing
    args = parser.parse_args()

    # Setup logger
    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s %(message)s", level=args.log_level
    )
    logging.captureWarnings(True)
    warnings.filterwarnings("once")

    # Load and validate json config file
    try:
        config = json.loads(args.config.read_text(encoding="UTF-8"))
        validate(config, json.loads(JSON_SCHEMA))
    except json.JSONDecodeError:
        logger.exception("The provided config file is not valid JSON!")
        sys.exit(1)
    except ValidationError:
        logger.exception(
            "The provided config file does not validate against the JSON schema!")
        sys.exit(1)

    # Construct session
    logger.info("Opening Zenoh session...")
    zconf = zenoh.Config()

    if args.connect is not None:
        zconf.insert_json5(zenoh.config.CONNECT_KEY, json.dumps(args.connect))

    with zenoh.open(zconf) as session:
        # Dispatch to correct function
        try:
            run(session, args, config)
        except KeyboardInterrupt:
            logger.info("Closing down on user request!")
            sys.exit(0)
