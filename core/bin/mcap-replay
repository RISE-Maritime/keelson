#!/usr/bin/env python3

import json
import time
import atexit
import logging
import pathlib
import argparse
from typing import Dict

import zenoh
from mcap.reader import make_reader
from mcap.records import Channel, Message


import brefv

logger = logging.getLogger("mcap-replay")

PUBLISHERS: Dict[str, zenoh.Publisher] = {}

def put(channel: Channel, message: Message):
    logger.debug("Preparing message on topic %s", channel.topic)

    publisher = PUBLISHERS[channel.id]
    envelope = brefv.enclose(payload=message.data, enclosed_at=message.publish_time)
    publisher.put(envelope)


def run(session: zenoh.Session, args: argparse.Namespace):

    with args.input.open("rb") as fh:
        reader = make_reader(fh)

        stats = reader.get_summary().statistics
        logger.info("Replaying from: %s", args.input)
        logger.info("...with %s channels", stats.channel_count)
        logger.info("...with %s message", stats.message_count)
        logger.info("...with %s chunks", stats.chunk_count)
        logger.info("...with %s schemas", stats.schema_count)
        logger.info("...first message at %s", stats.message_start_time)
        logger.info("...last message at %s", stats.message_end_time)


        for id, channel in reader.get_summary().channels.items():
            logger.info("Declaring publisher for: %s", channel.topic)
            PUBLISHERS[id] = session.declare_publisher(channel.topic)


        iterator = reader.iter_messages(log_time_order=True)

        # Fetch first one
        try:
            _, channel, message = next(iterator)
        except StopIteration:
            raise RuntimeError("File is empty!")
        
        # Send first envelope and set reference time
        first = message.log_time
        reference_time = time.time_ns()
        put(channel, message)

        for _, channel, message in iterator:

            current = message.log_time

            lag = current - first
            logger.debug("Lagging %s ns", lag)

            delay = time.time_ns() - reference_time
            if delay > 0:
                # time.sleep is not accurate enough for the full duration...
                while (time.time_ns() - reference_time) < lag:
                    time.sleep(10e-9)

            else:
                logger.warning("Negative delay: %s ns", delay)

            logger.debug("Putting to zenoh.")
            put(channel, message)
            


def main():
    parser = argparse.ArgumentParser(
        prog="replay",
        description="A pure python mcap replayer for keelson",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument("--log-level", type=int, default=logging.INFO)

    parser.add_argument(
        "-i",
        "--input",
        type=pathlib.Path,
        required=True,
        help="File path to read recorded data from",
    )

    ## Parse arguments and start doing our thing
    args = parser.parse_args()

    # Setup logger
    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s %(message)s", level=args.log_level
    )
    logging.captureWarnings(True)
    zenoh.init_logger()

    # Put together zenoh session configuration
    conf = zenoh.Config()
    conf.insert_json5(zenoh.config.MODE_KEY, json.dumps("peer"))

    ## Construct session
    logger.info("Opening Zenoh session...")
    session = zenoh.open(conf)

    def _on_exit():
        session.close()

    atexit.register(_on_exit)

    try:
        run(session, args)
    except KeyboardInterrupt:
        logging.info("Closing down on user reuqest... (Ctrl-C)")



if __name__ == "__main__":
    main()
