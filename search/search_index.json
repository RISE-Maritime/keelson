{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the documentation for <code>keelson</code>","text":"<p>NOTE: Keelson is in the early phases of development and will undergo significant changes before reaching v1.0. Be aware!</p> <p><code>keelson</code> is a start towards an open maritime API specification designed for building distributed maritime applications on top of the Zenoh communication protocol (1). It is provided as free and open-source software under the Apache 2.0 License.</p> <ol> <li> <p>In order to ease the introduction to keelson, make sure you are acquainted with zenoh. The following are some good resources:  </p> <ul> <li>What is Zenoh? </li> <li>Zenoh in action </li> <li>The basic abstractions </li> <li>Zenoh: Unifying Communication, Storage and Computation from the Cloud to the Microcontroller</li> <li>Github repository</li> </ul> </li> </ol>"},{"location":"#what-is-a-keelson","title":"What is a keelson?","text":"<p>A keelson is a longitudinal structure running above and fastened to the keel of a ship to strengthen its framework. <code>keelson</code>, the software, serves as the flexible and performant backbone for maritime data.</p>"},{"location":"#what-keelson-offers","title":"What <code>keelson</code> offers","text":"<p>In short, to assist in developing distributed applications on top of zenoh, keelson has opinions and requirements about:</p> <ul> <li>The format of the key used when publishing data to zenoh</li> <li>The format of the data published to zenoh</li> <li>The format of the key used when declaring a queryable (i.e. RPC endpoint) in zenoh</li> <li>The format of the requests and responses exchanged via a queryable (i.e. RPC endpoint) in zenoh</li> </ul> <p>For details about requirements on formats and message types, see the protocol specification.</p>"},{"location":"#why-use-keelson","title":"Why use <code>keelson</code>?","text":""},{"location":"#usage-at-rise-maritime","title":"Usage at RISE Maritime","text":"<p><code>keelson</code> serves as RISE Maritime\u2019s backbone for structuring a wide range of microservices, enabling the development of robust platforms for diverse maritime applications. Whether it\u2019s a logging server, unmanned surface vehicle control system, remote control center, or any other maritime-related system, <code>keelson</code>'s modular architecture allows for flexible integration and scalability.</p> <p></p> <p>Most of what we do at RISE Maritime becomes open source software. Have a look at RISE Maritime's GitHub page to explore various connectors, processors and other tools built using <code>keelson</code>.</p>"},{"location":"existing-resources/","title":"Existing resources","text":""},{"location":"existing-resources/#core-connectors","title":"Core connectors","text":"<ul> <li>AIS</li> <li>Camera</li> <li>Foxglove</li> <li>Klog</li> <li>MCAP</li> <li>Mediamtx</li> <li>Mockups</li> <li>NMEA</li> <li>Platform</li> </ul>"},{"location":"existing-resources/#connectors","title":"Connectors","text":"<p>Link to: Github Keelson Connectors</p>"},{"location":"existing-resources/#external-processors","title":"External processors","text":"<p>Link to: Github Keelson PROCESSORS</p>"},{"location":"health-monitoring/","title":"Health Monitoring","text":"<p>Keelson's layered health monitoring provides generic building blocks \u2014 presence detection, health scoring, and composite aggregation \u2014 that any application-specific decision layer can consume.</p> <p>Phase 1 status: This document covers the protocol conventions, message definitions, and reference configuration schema. The aggregator implementation is planned for Phase 2.</p>"},{"location":"health-monitoring/#overview","title":"Overview","text":"<p>Health monitoring in keelson follows a 3-layer architecture:</p> Layer Responsibility Mechanism Layer 1 \u2014 Presence Detect whether source processes are running Zenoh liveliness tokens Layer 2 \u2014 Health assessment Evaluate per-component health; produce a composite score Health aggregator (configurable) Layer 3 \u2014 Application logic Consume the composite score to drive domain-specific decisions Application-defined (see examples below) <p>Layers 1\u20132 are generic keelson infrastructure. Layer 3 is where applications map the composite score to actionable decisions.</p>"},{"location":"health-monitoring/#layer-1-liveliness-presence-detection","title":"Layer 1: Liveliness (Presence Detection)","text":"<p>Each source process declares a liveliness token using the convention defined in the protocol specification, Section 5:</p> <pre><code>{base_path}/@v0/{entity_id}/pubsub/*/{source_id}\n</code></pre> <p>The <code>*</code> wildcard in the subject position signals that the source is alive and may produce output on any subject. This is a coarse presence signal \u2014 the token does not declare which specific subjects the source publishes.</p> <p>A health aggregator subscribes to liveliness events to detect source join/leave:</p> <pre><code>session.liveliness().declare_subscriber(\n    \"keelson/@v0/landkrabban/pubsub/**\",\n    callback,\n)\n</code></pre> <p>See protocol specification, Section 5 for full details on token format, subscriber patterns, and verbatim chunk isolation.</p>"},{"location":"health-monitoring/#declaring-liveliness-in-connectors","title":"Declaring liveliness in connectors","text":"<p>Any connector that publishes data into keelson (a source/ingestion connector) should declare a liveliness token. The token signals \"this source process is alive and may produce output.\"</p> <p>When to declare: Source connectors that publish to <code>pubsub/</code> key expressions, such as <code>ais2keelson</code>, <code>n2k2keelson</code>, <code>nmea01832keelson</code>, or <code>platform-geometry2keelson</code>.</p> <p>When NOT to declare: - Sink connectors (subscribers/recorders like <code>keelson2foxglove</code>, <code>keelson2mcap</code>) \u2014 they have no <code>--source-id</code> and don't publish into keelson - Offline utilities (<code>klog2mcap</code>, <code>mcap-tagg</code>) \u2014 not long-running network processes - RPC-only services (<code>mediamtx-whep</code>) \u2014 until a separate RPC liveliness convention is defined</p> <p>Pattern: Use the <code>declare_liveliness_token</code> context manager from <code>keelson.scaffolding</code> immediately after opening the Zenoh session. The token is automatically undeclared when the <code>with</code> block exits:</p> <pre><code>from keelson.scaffolding import declare_liveliness_token\n\nwith zenoh.open(conf) as session:\n    with declare_liveliness_token(session, args.realm, args.entity_id, args.source_id):\n        run(session, args)\n</code></pre> <p>What it gives you: Health aggregators and monitoring UIs can detect source join/leave events without polling. When a connector process starts, it appears in the liveliness set; when it exits (cleanly or via crash), the token is automatically removed and subscribers receive a leave event.</p>"},{"location":"health-monitoring/#layer-2-health-aggregation","title":"Layer 2: Health Aggregation","text":"<p>The health aggregator is a generic, configurable component that produces a single composite score (0.0\u20131.0) for downstream consumers. It evaluates per-component health using a weighted scoring model. Each component is assigned:</p> <ul> <li>weight \u2014 its relative importance in the composite score (all weights should sum to 1.0)</li> <li>stale_threshold_ms \u2014 maximum age of the last received message before the component is considered stale (health score \u2192 0.0)</li> <li>health_rules \u2014 conditions evaluated against incoming messages</li> </ul>"},{"location":"health-monitoring/#health-rules","title":"Health rules","text":"<p>Each rule inspects a specific subject and evaluates a condition:</p> Rule type Description Example Value threshold Numeric comparison against a message field <code>good_if: \"value &lt; 2.0\"</code> Enum/state requirement Exact match against an expected value <code>require: \"FIX_3D\"</code> Message rate Frequency of messages on a subject <code>good_if: \"&gt; 20 Hz\"</code> <p>A component's health score is determined by the worst-performing rule:</p> <ul> <li>All rules pass <code>good_if</code> \u2192 score = 1.0</li> <li>At least one rule in <code>degraded_if</code> range \u2192 score = 0.5</li> <li>Any rule fails all conditions or the component is stale \u2192 score = 0.0</li> </ul>"},{"location":"health-monitoring/#composite-score","title":"Composite score","text":"<p>The composite score is the weighted sum of all component scores:</p> <pre><code>composite_score = \u03a3 (component_weight \u00d7 component_score)\n</code></pre> <p>This normalized score is the output of Layer 2. Layer 3 consumers interpret it according to their own domain logic.</p>"},{"location":"health-monitoring/#layer-3-application-specific-decision-logic","title":"Layer 3: Application-Specific Decision Logic","text":"<p>The composite score produced by Layer 2 is the input to whatever domain-specific logic a deployment requires. Applications subscribe to the composite score and apply their own rules to translate it into actionable decisions. Keelson does not prescribe what those decisions are \u2014 it only guarantees a well-defined, normalized health signal.</p> <p>Example use cases:</p> <ul> <li>Operational authority for autonomous vessels \u2014 map the composite score to authority levels (detailed below)</li> <li>Dashboard health indicators \u2014 translate the score into green / yellow / red status for operator UIs</li> <li>Automated alerting or degraded-mode switching \u2014 trigger alarms or fall back to a safe mode when the score drops below a threshold</li> </ul>"},{"location":"health-monitoring/#example-operational-authority-for-autonomous-vessels","title":"Example: Operational Authority for Autonomous Vessels","text":"<p>This built-in example maps the composite score to operational authority levels aligned with the IMO MASS (Maritime Autonomous Surface Ships) framework.</p> <p>The aggregator publishes an <code>OperationalAuthority</code> message to:</p> <pre><code>{base_path}/@v0/{entity_id}/pubsub/operational_authority/{aggregator_id}\n</code></pre>"},{"location":"health-monitoring/#message-format","title":"Message format","text":"<p>The message contains:</p> Field Type Description <code>timestamp</code> <code>google.protobuf.Timestamp</code> Time of the authority determination <code>level</code> <code>AuthorityLevel</code> enum Current authority level <code>composite_score</code> <code>float</code> Normalized composite health score (0.0\u20131.0) <code>reason</code> <code>string</code> Human-readable explanation <code>component_scores</code> <code>map&lt;string, float&gt;</code> Per-component health scores for observability"},{"location":"health-monitoring/#authority-levels","title":"Authority levels","text":"<p>The <code>AuthorityLevel</code> enum is aligned with the IMO MASS framework:</p> Value Name Description 0 <code>AUTHORITY_LEVEL_UNKNOWN</code> Authority level has not been determined 1 <code>AUTHORITY_LEVEL_MINIMAL_SAFE_MODE</code> Minimal safe operation (e.g., all-stop, hold position) 2 <code>AUTHORITY_LEVEL_SUPERVISED_REMOTE</code> Remote operator with limited situational awareness 3 <code>AUTHORITY_LEVEL_REMOTE_CONTROLLED</code> Full remote control with good situational awareness 4 <code>AUTHORITY_LEVEL_ASSISTED_AUTONOMOUS</code> Autonomous with operator supervision 5 <code>AUTHORITY_LEVEL_FULL_AUTONOMOUS</code> Fully autonomous operation"},{"location":"health-monitoring/#authority-thresholds-and-hysteresis","title":"Authority thresholds and hysteresis","text":"<p>The composite score is mapped to an authority level using configurable thresholds. The aggregator selects the highest authority level whose threshold is met:</p> Authority level Default threshold <code>FULL_AUTONOMOUS</code> \u2265 0.85 <code>ASSISTED_AUTONOMOUS</code> \u2265 0.65 <code>REMOTE_CONTROLLED</code> \u2265 0.45 <code>SUPERVISED_REMOTE</code> \u2265 0.25 <code>MINIMAL_SAFE_MODE</code> &lt; 0.25 <p>A hysteresis band (default: 0.05) prevents rapid oscillation between levels. Transitioning down requires the score to drop below <code>threshold - hysteresis</code>, and transitioning up requires the score to exceed <code>threshold + hysteresis</code>.</p>"},{"location":"how-to-use/","title":"How to use","text":"<p><code>keelson</code> currently provides Software Development Kits (SDKs) in two languages: <code>Python</code> and <code>Javascript/Typescript</code>. Using an SDK is not a requirement to adhere to the protocol defined by keelson but it typically helps.</p> <p>The <code>Python</code> SDK is available from PyPI.</p> <p>The <code>Javascript/Typescript</code> SDK is available from NPM.</p> <p>Further, the <code>zenoh-cli</code> (also written in <code>Python</code>) can be of great help to probe an existing <code>Zenoh</code> infrastructure. <code>keelson</code> provides a plugin to <code>zenoh-cli</code>(part of the <code>Python</code> SDK) to enhance <code>zenoh-cli</code> with an understanding of its well-known subjects and protobuf types.</p>"},{"location":"how-to-use/#examples","title":"Examples","text":"PythonJavascript <p>Publishing data to Zenoh</p> <pre><code>import zenoh\nimport keelson\nfrom keelson.scaffolding import create_zenoh_config\n\n# Open a Zenoh session\nconf = create_zenoh_config(mode=\"peer\")\nsession = zenoh.open(conf)\n\n# Construct a key expression for a well-known subject\nkey = keelson.construct_pubsub_key(\n    base_path=\"my_realm\",\n    entity_id=\"my_vessel\",\n    subject=\"location_fix\",\n    source_id=\"gps/0\",\n)\n\n# Declare a publisher\npub = session.declare_publisher(key)\n\n# Build a protobuf payload (e.g. a LocationFix)\nfrom keelson.payloads.foxglove.LocationFix_pb2 import LocationFix\n\npayload = LocationFix()\npayload.latitude = 57.706\npayload.longitude = 11.937\n\n# Enclose the serialized payload in a keelson envelope and publish\nenvelope = keelson.enclose(payload.SerializeToString())\npub.put(envelope)\n\nsession.close()\n</code></pre> <p>Subscribing to data from Zenoh</p> <pre><code>import zenoh\nimport keelson\nfrom keelson.scaffolding import create_zenoh_config\n\nconf = create_zenoh_config(mode=\"peer\")\nsession = zenoh.open(conf)\n\ndef on_sample(sample):\n    key = str(sample.key_expr)\n    received_at, enclosed_at, payload = keelson.uncover(\n        sample.payload.to_bytes()\n    )\n\n    # Get the subject from the key to know how to decode\n    subject = keelson.get_subject_from_pubsub_key(key)\n    schema = keelson.get_subject_schema(subject)\n    message = keelson.decode_protobuf_payload_from_type_name(payload, schema)\n    print(f\"Received on {key}: {message}\")\n\n# Subscribe using a wildcard key expression\nsub = session.declare_subscriber(\n    \"my_realm/v0/my_vessel/pubsub/**\",\n    on_sample,\n)\n\n# Keep running until interrupted\nimport time\ntry:\n    while True:\n        time.sleep(1)\nexcept KeyboardInterrupt:\n    pass\n\nsession.close()\n</code></pre> <p>The Javascript/Typescript SDK is available on NPM. See the JS SDK README for usage examples and API documentation.</p>"},{"location":"interfaces/","title":"Generic interfaces","text":"<p>These are well-known, well-specified interface definitions in use in <code>keelson</code>. Some noteworthy details: </p> <ul> <li>The <code>JSON</code> message type referenced below refers to the use of actual JSON-encoded structures, instead of protobuf-encoded binary payloads. </li> <li>Unfortunately, there exists NO code generation tool for creating stubs from these definitions as of now. </li> <li>Implementing an interface in zenoh makes use of queryables.</li> </ul> <p>In all cases, errors in a queryable MUST be handled according to: </p> <ul> <li>Using the <code>reply_err</code> functionality of a queryable. </li> <li>Replying with an <code>ErrorResponse</code> </li> </ul>"},{"location":"interfaces/#whepproxy","title":"WHEPProxy","text":""},{"location":"interfaces/#configurable","title":"Configurable","text":""},{"location":"interfaces/#subscriber","title":"Subscriber","text":""},{"location":"interfaces/#networkpingpong","title":"NetworkPingPong","text":""},{"location":"protocol-specification/","title":"Protocol specification","text":"<p>In short, keelson has opinions about:</p> <ul> <li>The format of the key used when publishing data to zenoh</li> <li>The format of the data published to zenoh</li> <li>The format of the key used when declaring a queryable (i.e. RPC endpoint) in zenoh</li> <li>The format of the requests and responses exchanged via a queryable (i.e. RPC endpoint) in zenoh</li> </ul>"},{"location":"protocol-specification/#1-common-key-space-design","title":"1. Common key-space design","text":"<p>In zenoh, both pub/sub and req/rep (queryables) messaging patterns all live in the same shared key \"space\". In keelson, the shared key-space has a common base hierarchy of three (3) levels:</p> <p><code>{base_path}/@v{major_version}/{entity_id}/...</code></p> <p>With:</p> <ul> <li><code>base_path</code> being any base_path where to operate</li> <li><code>@v{major_version}</code> is the major version of keelson used, the leading <code>@</code> makes this a verbatim chunk, allowing separation of different major versions.</li> <li><code>entity_id</code> being a unique id representing an entity within the realm (Normally the platform name ei. landkrabban, masslab, logging_pc_one)</li> <li><code>...</code> are specific key levels depending on the messaging pattern, these are further described below.</li> </ul> <p>NOTE: Without exceptions, keys should adhere to <code>snake_case</code> style.</p> <p>NOTE: Verbatim chunks allows some key spaces to be hermetically sealed from each other. Any chunk that starts with <code>@</code> is treated as a verbatim chunk, and can only be matched by an identical chunk. In general, verbatim chunks are useful in ensuring that <code>*</code> and <code>**</code> accidentally match chunks that are not supposed to be matched. A common case is API versioning where <code>@v1</code> and <code>@v2</code> should not be mixed or at least explicitly selected.</p>"},{"location":"protocol-specification/#publish-subscribe-rpc-queryable","title":"Publish, Subscribe &amp; RPC (Queryable)","text":"<p>RPC stands for remote procedure call and refers to the queryables in zenoh. So both connectors and processors can use both pubsub and rpc (queryables) depending on how the api is designed.</p>"},{"location":"protocol-specification/#2-pubsub-publish-subscribe-messaging","title":"2. PUBSUB - Publish- Subscribe messaging","text":""},{"location":"protocol-specification/#21-specific-key-space-design","title":"2.1 Specific key-space design","text":"<p>For pub/sub messaging, the lower levels of the key-space has the following levels:</p> <p><code>.../pubsub/{subject}/{source_id}</code></p> <p>With</p> <ul> <li><code>pubsub</code> being the hard-coded word \"pubsub\" letting users directly identify key expression category  </li> <li><code>subject</code> being a well-known subject describing the information contained within the payloads published to this key. The concept of subjects is further described under Data format below.</li> <li><code>source_id</code> being a unique id for the source producing the information described by <code>subject</code>. <code>source_id</code> may contain any number of addititional levels (i.e. forward slashes <code>/</code>) ei. camera/rbg/0</li> </ul>"},{"location":"protocol-specification/#211-target-extension","title":"2.1.1 Target Extension","text":"<p>When a source produces data about external entities (rather than the entity running the source itself), the key can include an optional <code>@target</code> extension:</p> <p><code>.../pubsub/{subject}/{source_id}/@target/{target_id}</code></p> <p>With:</p> <ul> <li><code>@target</code> being the hard-coded word \"@target\" indicating this data refers to an external entity. The <code>@</code> makes this a verbatim chunk.</li> <li><code>target_id</code> being a unique identifier for the referred entity (e.g., <code>mmsi_245060000</code> for an AIS-tracked vessel).</li> </ul> <p>Example: An AIS receiver on entity <code>shore_station</code> publishing heading data about vessel with MMSI 245060000:</p> <pre><code>keelson/@v0/shore_station/pubsub/heading_true_north_deg/ais/@target/mmsi_245060000\n</code></pre>"},{"location":"protocol-specification/#verbatim-chunk-isolation","title":"Verbatim chunk isolation","text":"<p>The <code>@target</code> prefix is a verbatim chunk, meaning it is hermetically isolated from wildcards. This is an intentional design decision:</p> <ul> <li>A subscriber to <code>.../pubsub/{subject}/{source_id}</code> will NOT receive messages with <code>@target</code> extensions</li> <li>A subscriber to <code>.../pubsub/{subject}/{source_id}/**</code> will NOT receive messages with <code>@target</code> extensions (wildcards cannot cross verbatim boundaries)</li> <li>To receive targeted messages, subscribers MUST explicitly include <code>@target</code> in their patterns</li> </ul> <p>Subscription pattern examples for key <code>.../pubsub/location_fix/ais/@target/mmsi_123456</code>:</p> Pattern Matches? Reason <code>.../ais</code> No Different key length <code>.../ais/**</code> No <code>**</code> cannot cross verbatim <code>@target</code> <code>.../ais/*</code> No <code>*</code> cannot match verbatim <code>@target</code> <code>.../ais/@target/**</code> Yes Explicit verbatim match <code>.../ais/@target/mmsi_*</code> Yes Verbatim @target + wildcard <p>To receive both targeted and non-targeted messages from a source, subscribers need multiple patterns: * <code>.../pubsub/{subject}/{source_id}</code> \u2014 non-targeted messages * <code>.../pubsub/{subject}/{source_id}/@target/**</code> \u2014 all targeted messages</p>"},{"location":"protocol-specification/#when-to-use-target","title":"When to use @target","text":"<p>Use the <code>@target</code> extension when: * The source observes or tracks external entities (e.g., AIS receivers tracking other vessels) * Data describes something other than the entity running the source * You need to distinguish between self-observations and observations of others</p> <p>Do NOT use <code>@target</code> when: * The data describes the entity itself (e.g., own-ship position from onboard GNSS) * The source_id sufficiently identifies the data origin</p>"},{"location":"protocol-specification/#22-message-format-specification","title":"2.2 Message format specification","text":"<p>Each message published to zenoh must be a protobuf-encoded keelson <code>Envelope</code>. An <code>Envelope</code> contains exactly one (1) <code>payload</code>, we say that a <code>payload</code> is enclosed within an <code>Envelope</code> by the publisher and can later be uncovered from that <code>Envelope</code> by the subscriber. </p> <p>sketch</p> <p>Keelson support a set of well-known <code>payload</code>s, defined by the protobuf schemas available in messages. Each well-known <code>payload</code> is associated with an informative <code>subject</code>, the mapping between <code>subject</code>s and <code>payload</code>s is maintained in a look-up table in YAML format.</p> <p>The main design principles behind this scheme are:</p> <ul> <li>Well-known payloads are defined by a schema that describes how to interpret the data.</li> <li>Each (well-known) payload is associated with one or more subjects that describes how to interpret the information.</li> <li>Each subject or procedure is part of the key when publishing data to zenoh, refer to the section about keys, this helps the sender and receiver to put the information into a context.</li> </ul>"},{"location":"protocol-specification/#221-naming-convention-for-subjects-category","title":"2.2.1 Naming convention for <code>subject</code>s category","text":"<p>There are three distinct kind of payloads that has to be covered by a naming convention for <code>subject</code>s:</p> <ul> <li>raw \"arbitrary bytes\", where we do not know the schema or do not want to express the schema as a protobuf type, these all fall under the special subject <code>raw</code> using the payload type <code>TimestampedBytes</code></li> <li>primitive payloads, which have a specific meaning but where the protobuf type is generic, i.e <code>TimestampedFloat</code> or similar. In this case the subject needs to be very informative with regards to that value and we employ the following convention: <code>&lt;entity&gt;_&lt;property&gt;_&lt;unit&gt;</code> where <code>entity</code>, <code>property</code> and <code>unit</code> are constrained to alphanumeric characters. For example <code>rudder_angle_deg</code>.</li> <li>complex payloads, which have a specific protobuf type that is not shared with any other subject. In this case, the subject name should be the snake_case version of the protobuf message name, for example <code>RawImage</code> -&gt; <code>raw_image</code>.</li> </ul> <p>In general, <code>subjects.yaml</code> contains the current well-known subjects and can be regarded as the style-guide to follow.</p>"},{"location":"protocol-specification/#units-summary-in-subjects","title":"Units Summary in Subjects","text":"Unit Symbol Full Unit Name Example Subjects Using It m meter location_fix_accuracy_horizontal_m, draught_mean_m, altitude_msl_m deg degree (angle) heading_true_north_deg, roll_deg, target_bearing_relative_deg degps degrees per second roll_rate_degps, yaw_rate_degps knots nautical miles per hour speed_over_ground_knots, speed_through_water_knots pct percent engine_throttle_pct, wheel_position_pct, battery_state_of_charge_pct rpm revolutions per minute propeller_rate_rpm, engine_rate_rpm celsius degrees Celsius engine_oil_temperature_celsius, air_temperature_celsius psi pounds per square inch engine_oil_pressure_psi, engine_coolant_pressure_psi lph liters per hour engine_fuel_rate_lph l liters engine_fuel_consumed_l volt volts battery_voltage_volt, battery_min_voltage_volt amp amperes battery_current_amp amph ampere-hours battery_capacity_amph ah ampere-hours battery_current_consumed_ah wh watt-hours battery_energy_consumed_wh sec seconds battery_time_remaining_sec, device_uptime_duration hpa hectopascal air_pressure_hpa ppt parts per thousand water_salinity_ppt mps meters per second true_wind_speed_mps, climb_rate_mps, surge_velocity_mps mpss meters per second squared linear_acceleration_mpss, surge_acceleration_mpss radps radians per second angular_velocity_radps gauss gauss (magnetic field strength) magnetic_field_gauss s seconds heave_period_s, target_tcpa_s newton newtons force_newton newton_meter newton-meters moment_newton_meter"},{"location":"protocol-specification/#3-query-request-reply-messaging-remote-procedure-calls","title":"3. Query - Request-Reply messaging (Remote Procedure Calls)","text":""},{"location":"protocol-specification/#31-specific-key-space-design","title":"3.1 Specific key-space design","text":"<p>For the request / reply messaging pattern, the lower level hierarchy in the key space consists of the following levels:</p> <p><code>.../@rpc/{procedure}/source_id</code></p> <p>With:</p> <ul> <li><code>@rpc</code> being the hardcoded word \"@rpc\" letting users directly identify key expression category. The <code>@</code>makes this a verbatim chunk and ensures it cant be mixed up with other chunks such as <code>pubsub</code>.</li> <li><code>procedure</code>  being a well-known procedure name as defined in a protobuf service.</li> <li><code>source_id</code> being the platform unique name of the micro-service either an keelson connector or processor, may contain any number of additional levels (i.e. forward slashes <code>/</code>) ei. camera/mono/0 or lidar/0</li> </ul>"},{"location":"protocol-specification/#32-interface-specification","title":"3.2 Interface specification","text":"<p>Zenoh supports a generalized version of Remote Procedure Calls, namely queryables. This is leveraged for Request/Response messaging (RPC) in keelson with the following additional decrees:</p> <ul> <li>All RPC endpoints (queryables) should be defined by a protobuf service definition and thus accept Requests and return Responses in protobuf format.</li> <li>All RPC endpoints (queryables) should make use of the common <code>ErrorResponse</code> return type and the <code>reply_err</code> functionality in zenoh to propagate errors from callee to caller.</li> </ul>"},{"location":"protocol-specification/#4-message-definition-specification","title":"4. Message definition specification","text":"<p>Most messages include a timestamp field, following the Google Protobuf Timestamp specification. The primary timestamp represents the system time of the logging computer. If synchronization with, or tracking of, other timekeeping devices or systems is logged with subject <code>time</code>.</p>"},{"location":"protocol-specification/#5-liveliness-key-space-convention","title":"5. Liveliness key-space convention","text":"<p>Keelson uses Zenoh liveliness tokens to provide coarse-grained presence detection for sources (Layer 1 of the health monitoring architecture). A liveliness token signals that a source process is running and may produce output on any subject.</p>"},{"location":"protocol-specification/#51-token-key-format","title":"5.1 Token key format","text":"<p>Each source declares a single liveliness token using a wildcard (<code>*</code>) in the subject position:</p> <pre><code>{base_path}/@v0/{entity_id}/pubsub/*/{source_id}\n</code></pre> <p>For example, a GNSS source on the entity <code>landkrabban</code>:</p> <pre><code>keelson/@v0/landkrabban/pubsub/*/gnss/0\n</code></pre> <p>The <code>*</code> in the subject position means \"this source is alive and may produce output on any subject.\" It is a presence signal, not a capability declaration \u2014 the token does not specify which subjects the source actually publishes.</p> <p>NOTE: Zenoh treats <code>*</code> in a token declaration as a pattern. This means the token will match any concrete subject query (e.g., a query for <code>pubsub/location_fix/gnss/0</code> will match the token <code>pubsub/*/gnss/0</code>). This is intentional \u2014 it allows presence to be discovered alongside subject-specific queries. Future versions may introduce concrete per-subject tokens for fine-grained capability declarations.</p>"},{"location":"protocol-specification/#52-subscriber-key-patterns","title":"5.2 Subscriber key patterns","text":"<p>To monitor presence of all sources within an entity:</p> <pre><code>{base_path}/@v0/{entity_id}/pubsub/**\n</code></pre> <p>To monitor presence across all entities:</p> <pre><code>{base_path}/@v0/**/pubsub/**\n</code></pre> <p>A liveliness subscriber on these patterns will receive join and leave events as sources declare and undeclare their tokens.</p>"},{"location":"protocol-specification/#53-querying-live-tokens","title":"5.3 Querying live tokens","text":"<p>To retrieve all currently live tokens for an entity:</p> <pre><code>replies = session.liveliness().get(\"keelson/@v0/landkrabban/pubsub/**\")\nfor reply in replies:\n    print(reply.ok.key_expr)  # e.g. keelson/@v0/landkrabban/pubsub/*/gnss/0\n</code></pre>"},{"location":"protocol-specification/#54-verbatim-chunk-isolation","title":"5.4 Verbatim chunk isolation","text":"<p>The <code>@v0</code> verbatim chunk guarantees that liveliness tokens and subscribers for different major versions are isolated from each other. A subscriber on <code>@v0/**</code> will never receive events from tokens declared under <code>@v1/**</code>, and vice versa. This is enforced by Zenoh's verbatim chunk matching rules (see Section 1).</p>"},{"location":"subjects-and-types/","title":"Well-known subjects and protobuf types","text":"Subject Fully qualified protobuf type name <code>raw</code> keelson.TimestampedBytes <code>raw_json</code> keelson.TimestampedString <code>raw_nmea0183</code> keelson.TimestampedString <code>raw_nmea2000</code> keelson.TimestampedBytes <code>raw_lwe450</code> keelson.TimestampedBytes <code>configuration_json</code> keelson.TimestampedString <code>log_message</code> foxglove.Log <code>sensor_status</code> keelson.SensorStatus <code>network_status</code> keelson.NetworkStatus <code>simulation_status</code> keelson.SimulationStatus <code>roc_status</code> keelson.ROCStatus <code>operational_authority</code> keelson.OperationalAuthority <code>frame_transform</code> foxglove.FrameTransform <code>location_fix</code> foxglove.LocationFix <code>location_fix_accuracy_horizontal_m</code> keelson.TimestampedFloat <code>location_fix_accuracy_vertical_m</code> keelson.TimestampedFloat <code>location_fix_satellites_visible</code> keelson.TimestampedInt <code>location_fix_satellites_used</code> keelson.TimestampedInt <code>location_fix_quality</code> keelson.LocationFixQuality <code>location_fix_hdop</code> keelson.TimestampedFloat <code>location_fix_vdop</code> keelson.TimestampedFloat <code>location_fix_pdop</code> keelson.TimestampedFloat <code>gnss_error_rms_m</code> keelson.TimestampedFloat <code>gnss_error_semi_major_axis_m</code> keelson.TimestampedFloat <code>gnss_error_semi_minor_axis_m</code> keelson.TimestampedFloat <code>gnss_error_orientation_deg</code> keelson.TimestampedFloat <code>gnss_error_latitude_m</code> keelson.TimestampedFloat <code>gnss_error_longitude_m</code> keelson.TimestampedFloat <code>gnss_error_altitude_m</code> keelson.TimestampedFloat <code>location_fix_undulation_m</code> keelson.TimestampedFloat <code>vessel_outline_geojson</code> keelson.TimestampedGeoJSON <code>no_go_zone_geojson</code> keelson.TimestampedGeoJSON <code>navigable_waters_geojson</code> keelson.TimestampedGeoJSON <code>waypoint_geojson</code> keelson.TimestampedGeoJSON <code>heading_true_north_deg</code> keelson.TimestampedFloat <code>heading_magnetic_deg</code> keelson.TimestampedFloat <code>course_over_ground_deg</code> keelson.TimestampedFloat <code>speed_over_ground_knots</code> keelson.TimestampedFloat <code>speed_through_water_knots</code> keelson.TimestampedFloat <code>speed_through_air_knots</code> keelson.TimestampedFloat <code>vessel_type</code> keelson.VesselType <code>name</code> keelson.TimestampedString <code>imo_number</code> keelson.TimestampedInt <code>mmsi_number</code> keelson.TimestampedInt <code>call_sign</code> keelson.TimestampedString <code>flag_code</code> keelson.FlagCode <code>nav_status</code> keelson.VesselNavStatus <code>roll_deg</code> keelson.TimestampedFloat <code>roll_rate_degps</code> keelson.TimestampedFloat <code>pitch_deg</code> keelson.TimestampedFloat <code>pitch_rate_degps</code> keelson.TimestampedFloat <code>yaw_deg</code> keelson.TimestampedFloat <code>yaw_rate_degps</code> keelson.TimestampedFloat <code>orientation_quaternion</code> keelson.TimestampedQuaternion <code>length_over_all_m</code> keelson.TimestampedFloat <code>breadth_over_all_m</code> keelson.TimestampedFloat <code>draught_mean_m</code> keelson.TimestampedFloat <code>draught_max_m</code> keelson.TimestampedFloat <code>draught_stern_m</code> keelson.TimestampedFloat <code>draught_bow_m</code> keelson.TimestampedFloat <code>draught_midship_m</code> keelson.TimestampedFloat <code>wheel_position_pct</code> keelson.TimestampedFloat <code>lever_position_pct</code> keelson.TimestampedFloat <code>propeller_rate_rpm</code> keelson.TimestampedFloat <code>propeller_pitch_pct</code> keelson.TimestampedFloat <code>rudder_angle_deg</code> keelson.TimestampedFloat <code>engine_throttle_pct</code> keelson.TimestampedFloat <code>engine_rate_rpm</code> keelson.TimestampedFloat <code>engine_temperature_celsius</code> keelson.TimestampedFloat <code>engine_fuel_level_pct</code> keelson.TimestampedFloat <code>engine_fuel_rate_lph</code> keelson.TimestampedFloat <code>engine_fuel_consumed_l</code> keelson.TimestampedFloat <code>engine_oil_pressure_psi</code> keelson.TimestampedFloat <code>engine_oil_temperature_celsius</code> keelson.TimestampedFloat <code>engine_coolant_temperature_celsius</code> keelson.TimestampedFloat <code>engine_coolant_pressure_psi</code> keelson.TimestampedFloat <code>battery_type</code> keelson.TimestampedString <code>battery_state_of_charge_pct</code> keelson.TimestampedFloat <code>battery_voltage_v</code> keelson.TimestampedFloat <code>battery_current_a</code> keelson.TimestampedFloat <code>battery_temperature_celsius</code> keelson.TimestampedFloat <code>battery_min_voltage_v</code> keelson.TimestampedFloat <code>battery_max_voltage_v</code> keelson.TimestampedFloat <code>battery_capacity_ah</code> keelson.TimestampedFloat <code>battery_current_consumed_ah</code> keelson.TimestampedFloat <code>battery_energy_consumed_wh</code> keelson.TimestampedFloat <code>battery_time_remaining_s</code> keelson.TimestampedFloat <code>battery_is_charging</code> keelson.TimestampedBool <code>air_temperature_celsius</code> keelson.TimestampedFloat <code>air_relative_humidity_pct</code> keelson.TimestampedFloat <code>air_pressure_pa</code> keelson.TimestampedFloat <code>water_temperature_celsius</code> keelson.TimestampedFloat <code>water_salinity_ppt</code> keelson.TimestampedFloat <code>water_speed_of_sound_mps</code> keelson.TimestampedFloat <code>true_wind_direction_deg</code> keelson.TimestampedFloat <code>true_wind_angle_deg</code> keelson.TimestampedFloat <code>true_wind_speed_mps</code> keelson.TimestampedFloat <code>apparent_wind_angle_deg</code> keelson.TimestampedFloat <code>apparent_wind_speed_mps</code> keelson.TimestampedFloat <code>image_raw</code> foxglove.RawImage <code>image_compressed</code> foxglove.CompressedImage <code>video_compressed</code> foxglove.CompressedVideo <code>laser_scan</code> foxglove.LaserScan <code>point_cloud</code> foxglove.PointCloud <code>alarm</code> keelson.Alarm <code>audio</code> keelson.Audio <code>linear_acceleration_mpss</code> keelson.Decomposed3DVector <code>angular_velocity_radps</code> keelson.Decomposed3DVector <code>magnetic_field_gauss</code> keelson.Decomposed3DVector <code>ned_velocity_mps</code> keelson.Decomposed3DVector <code>surge_m</code> keelson.TimestampedFloat <code>sway_m</code> keelson.TimestampedFloat <code>heave_m</code> keelson.TimestampedFloat <code>surge_velocity_mps</code> keelson.TimestampedFloat <code>sway_velocity_mps</code> keelson.TimestampedFloat <code>heave_velocity_mps</code> keelson.TimestampedFloat <code>surge_acceleration_mpss</code> keelson.TimestampedFloat <code>sway_acceleration_mpss</code> keelson.TimestampedFloat <code>heave_acceleration_mpss</code> keelson.TimestampedFloat <code>heave_period_s</code> keelson.TimestampedFloat <code>force_newton</code> keelson.Decomposed3DVector <code>moment_newton_meter</code> keelson.Decomposed3DVector <code>imu_temperature_celsius</code> keelson.TimestampedFloat <code>integrated_circuit_temperature_celsius</code> keelson.TimestampedFloat <code>radar_spoke</code> keelson.RadarSpoke <code>radar_sweep</code> keelson.RadarSweep <code>target_type</code> keelson.TargetType <code>target_bearing_magnetic_deg</code> keelson.TimestampedFloat <code>target_bearing_north_deg</code> keelson.TimestampedFloat <code>target_bearing_relative_deg</code> keelson.TimestampedFloat <code>target_cpa_m</code> keelson.TimestampedFloat <code>target_tcpa_s</code> keelson.TimestampedFloat <code>target_bcr_m</code> keelson.TimestampedFloat <code>target_bct_s</code> keelson.TimestampedFloat <code>device_uptime_duration</code> keelson.TimestampedDuration <code>radio_channel_ppm_pct</code> keelson.TimestampedFloat <code>radio_rssi</code> keelson.TimestampedFloat <code>timestamp</code> keelson.TimestampedTimestamp <code>roll_accuracy_deg</code> keelson.TimestampedFloat <code>pitch_accuracy_deg</code> keelson.TimestampedFloat <code>heading_accuracy_deg</code> keelson.TimestampedFloat <code>gnss_aiding_status</code> keelson.TimestampedInt <code>imu_system_status</code> keelson.TimestampedInt <code>altitude_above_msl_m</code> keelson.TimestampedFloat <code>climb_rate_mps</code> keelson.TimestampedFloat"}]}