{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation for <code>keelson</code>","text":"<p>NOTE: Keelson is in the early phases of development and will undergo significant changes before reaching v1.0. Be aware!</p> <p><code>keelson</code> is a start towards an open maritime API specification designed for building distributed maritime applications on top of the Zenoh communication protocol (1). It is provided as free and open-source software under the Apache 2.0 License.</p> <ol> <li> <p>In order to ease the introduction to keelson, make sure you are aquainted with zenoh. The following are some good resources:  </p> <ul> <li>What is Zenoh? </li> <li>Zenoh in action </li> <li>The basic abstractions </li> <li>Zenoh: Unifying Communication, Storage and Computation from the Cloud to the Microcontroller</li> <li>Github repository</li> </ul> </li> </ol>"},{"location":"#what-is-a-keelson","title":"What is a keelson?","text":"<p>A keelson is a longitudinal structure running above and fastened to the keel of a ship to strengthen its framework. <code>keelson</code>, the software, serves as the flexible and performant backbone for maritime data.</p>"},{"location":"#what-keelson-offers","title":"What <code>keelson</code> offers","text":"<p>In short, to assist in developing distributed applications on top of zenoh, keelson has opinions and requirements about:</p> <ul> <li>The format of the key used when publishing data to zenoh</li> <li>The format of the data published to zenoh</li> <li>The format of the key used when declaring a queryable (i.e. RPC endpoint) in zenoh</li> <li>The format of the requests and responses exchanged via a queryable (i.e. RPC endpoint) in zenoh</li> </ul> <p>For details about requirements on formats and message types, see the protocol specification.</p>"},{"location":"#why-use-keelson","title":"Why use <code>keelson</code>?","text":""},{"location":"#usage-at-rise-maritime","title":"Usage at RISE Maritime","text":"<p><code>keelson</code> serves as RISE Maritime\u2019s backbone for structuring a wide range of microservices, enabling the development of robust platforms for diverse maritime applications. Whether it\u2019s a logging server, unmanned surface vehicle control system, remote control center, or any other maritime-related system, <code>keelson</code>'s modular architecture allows for flexible integration and scalability.</p> <p></p> <p>Most of what we do at RISE Maritime becomes open source software. Have a look at RISE Maritime's GitHub page to explor various connectors, processors and other tools built using <code>keelson</code>.</p>"},{"location":"existing-resources/","title":"Existing resources","text":""},{"location":"existing-resources/#core-connectors","title":"Core connectors","text":"<ul> <li>Klog</li> <li>MCAP</li> <li>Mediamtx</li> <li>Mockups</li> </ul>"},{"location":"existing-resources/#connectors","title":"Connectors","text":"<p>Link to: Github Keelson Connectors</p>"},{"location":"existing-resources/#external-processors","title":"External processors","text":"<p>Link to: Github Keelson PROCESSORS</p>"},{"location":"how-to-use/","title":"How to use","text":"<p><code>keelson</code> currently provides Software Development Kits (SDKs) in two languages: <code>Python</code> and <code>Javascript/Typescript</code>. Using an SDK is not a requirement to adhere to the protocol defined by keelson but it typically helps.</p> <p>The <code>Python</code> SDK is available from PyPI. </p> <p>The <code>Javascript/Typescript</code> SDK is available from NPM.</p> <p>Further, the <code>zenoh-cli</code> (also written in <code>Python</code>) can be of great help to probe an existing <code>Zenoh</code> infrastructure. <code>keelson</code> provides a plugin to <code>zenoh-cli</code>(part of the <code>Python</code> SDK) to enhance <code>zenoh-cli</code> with an understanding of its well-known subjects and protobuf types.</p>"},{"location":"how-to-use/#examples","title":"Examples","text":"PythonJavascript <pre><code>TODO\n</code></pre> <pre><code>TODO\n</code></pre>"},{"location":"interfaces/","title":"Generic interfaces","text":"<p>These are well-known, well-specified interface definitions in use in <code>keelson</code>. Some noteworthy details: </p> <ul> <li>The <code>JSON</code> message type referenced below refers to the use of actual JSON-encoded structures, instead of protobuf-encoded binary payloads. </li> <li>Unfortunately, there exists NO code generation tool for creating stubs from these definitions as of now. </li> <li>Implementing an interface in zenoh makes use of queryables.</li> </ul> <p>In all cases, errors in a queryable MUST be handled according to: </p> <ul> <li>Using the <code>reply_err</code> functionality of a queryable. </li> <li>Replying with an <code>ErrorResponse</code> </li> </ul>"},{"location":"interfaces/#subscriber","title":"Subscriber","text":""},{"location":"interfaces/#configurable","title":"Configurable","text":""},{"location":"interfaces/#whepproxy","title":"WHEPProxy","text":""},{"location":"interfaces/#networkpingpong","title":"NetworkPingPong","text":""},{"location":"protocol-specification/","title":"Protocol specification","text":"<p>In short, keelson has opinions about:</p> <ul> <li>The format of the key used when publishing data to zenoh</li> <li>The format of the data published to zenoh</li> <li>The format of the key used when declaring a queryable (i.e. RPC endpoint) in zenoh</li> <li>The format of the requests and responses exchanged via a queryable (i.e. RPC endpoint) in zenoh</li> </ul>"},{"location":"protocol-specification/#1-common-key-space-design","title":"1. Common key-space design","text":"<p>In zenoh, both pub/sub and req/rep (queryables) messaging patterns all live in the same shared key \"space\". In keelson, the shared key-space has a common base hierarchy of three (3) levels:</p> <p><code>{base_path}/@v{major_version}/{entity_id}/...</code></p> <p>With:</p> <ul> <li><code>base_path</code> being any base_path where to operate</li> <li><code>@v{major_version}</code> is the major version of keelson used, the leading <code>@</code> makes this a verbatim chunk, allowing separation of different major versions.</li> <li><code>entity_id</code> being a unique id representing an entity within the realm (Normally the platform name ei. landkrabban, masslab, logging_pc_one)</li> <li><code>...</code> are specific key levels depending on the messaging pattern, these are further described below.</li> </ul> <p>NOTE: Without exceptions, keys should adhere to <code>snake_case</code> style.</p> <p>NOTE: Verbatim chunks allows some key spaces to be hermetically sealed from each other. Any chunk that starts with <code>@</code> is treated as a verbatim chunk, and can only be matched by an identical chunk. In general, verbatim chunks are useful in ensuring that <code>*</code> and <code>**</code> accidentally match chunks that are not supposed to be matched. A common case is API versioning where <code>@v1</code> and <code>@v2</code> should not be mixed or at least explicitly selected.</p>"},{"location":"protocol-specification/#publish-subscribe-rpc-queryable","title":"Publish, Subscribe &amp; RPC (Queryable)","text":"<p>RPC stands for remote procedure call and refers to the queryables in zenoh. So both connectors and processors can use both pubsub and rpc (queryables) depending on how the api is designed.</p>"},{"location":"protocol-specification/#2-pubsub-publish-subscribe-messaging","title":"2. PUBSUB - Publish- Subscribe messaging","text":""},{"location":"protocol-specification/#21-specific-key-space-design","title":"2.1 Specific key-space design","text":"<p>For pub/sub messaging, the lower levels of the key-space has the following levels:</p> <p><code>.../pubsub/{subject}/{source_id}</code></p> <p>With</p> <ul> <li><code>pubsub</code> being the hard-coded word \"pubsub\" letting users directly identify key expression category  </li> <li><code>subject</code> being a well-known subject describing the information contained within the payloads published to this key. The concept of subjects is further described under Data format below.</li> <li><code>source_id</code> being a unique id for the source producing the information described by <code>subject</code>. <code>source_id</code> may contain any number of addititional levels (i.e. forward slashes <code>/</code>) ei. camera/rbg/0</li> </ul>"},{"location":"protocol-specification/#22-message-format-specification","title":"2.2 Message format specification","text":"<p>Each message published to zenoh must be a protobuf-encoded keelson <code>Envelope</code>. An <code>Envelope</code> contains exactly one (1) <code>payload</code>, we say that a <code>payload</code> is enclosed within an <code>Envelope</code> by the publisher and can later be uncovered from that <code>Envelope</code> by the subscriber. </p> <p>sketch</p> <p>Keelson support a set of well-known <code>payload</code>s, defined by the protobuf schemas available in messages. Each well-known <code>payload</code> is associated with an informative <code>subject</code>, the mapping between <code>subject</code>s and <code>payload</code>s is maintained in a look-up table in YAML format.</p> <p>The main design principles behind this scheme are:</p> <ul> <li>Well-known payloads are defined by a schema that describes how to interpret the data.</li> <li>Each (well-known) payload is associated with one or more subjects that describes how to interpret the information.</li> <li>Each subject or procedure is part of the key when publishing data to zenoh, refer to the section about keys, this helps the sender and receiver to put the information into a context.</li> </ul>"},{"location":"protocol-specification/#221-naming-convention-for-subjects-category","title":"2.2.1 Naming convention for <code>subject</code>s category","text":"<p>There are three distinct kind of payloads that has to be covered by a naming convention for <code>subject</code>s:</p> <ul> <li>raw \"arbitrary bytes\", where we do not know the schema or do not want to express the schema as a protobuf type, these all fall under the special subject <code>raw</code> using the payload type <code>TimestampedBytes</code></li> <li>primitive payloads, which have a specific meaning but where the protobuf type is generic, i.e <code>TimestampedFloat</code> or similar. In this case the subject needs to be very informative with regards to that value and we employ the following convention: <code>&lt;entity&gt;_&lt;property&gt;_&lt;unit&gt;</code> where <code>entity</code>, <code>property</code> and <code>unit</code> are constrained to alphanumeric characters. For example <code>rudder_angle_deg</code>.</li> <li>complex payloads, which have a specific protobuf type that is not shared with any other subject. In this case, the subject name should be the snake_case version of the protobuf message name, for example <code>RawImage</code> -&gt; <code>raw_image</code>.</li> </ul> <p>In general, <code>subjects.yaml</code> contains the current well-known subjects and can be regarded as the style-guide to follow.</p>"},{"location":"protocol-specification/#3-query-request-reply-messaging-remote-procedure-calls","title":"3. Query - Request-Reply messaging (Remote Procedure Calls)","text":""},{"location":"protocol-specification/#31-specific-key-space-design","title":"3.1 Specific key-space design","text":"<p>For the request / reply messaging pattern, the lower level hierarchy in the key space consists of the following levels:</p> <p><code>.../@rpc/{procedure}/source_id</code></p> <p>With:</p> <ul> <li><code>@rpc</code> being the hardcoded word \"@rpc\" letting users directly identify key expression category. The <code>@</code>makes this a verbatim chunk and ensures it cant be mixed up with other chunks such as <code>pubsub</code>.</li> <li><code>procedure</code>  being a well-known procedure name as defined in a protobuf service.</li> <li><code>source_id</code> being the platform unique name of the micro-service either an keelson connector or processor, may contain any number of additional levels (i.e. forward slashes <code>/</code>) ei. camera/mono/0 or lidar/0</li> </ul>"},{"location":"protocol-specification/#32-interface-specification","title":"3.2 Interface specification","text":"<p>Zenoh supports a generalized version of Remote Procedure Calls, namely queryables. This is leveraged for Request/Response messaging (RPC) in keelson with the following additional decrees:</p> <ul> <li>All RPC endpoints (queryables) should be defined by a protobuf service definition and thus accept Requests and return Responses in protobuf format.</li> <li>All RPC endpoints (queryables) should make use of the common <code>ErrorResponse</code> return type and the <code>reply_err</code> functionality in zenoh to propagate errors from callee to caller.</li> </ul>"},{"location":"subjects-and-types/","title":"Well-known subjects and protobuf types","text":"Subject Fully qualified protobuf type name <code>raw</code> keelson.TimestampedBytes <code>raw_json</code> keelson.TimestampedString <code>raw_nmea0183</code> keelson.TimestampedString <code>raw_nmea2000</code> keelson.TimestampedBytes <code>raw_lwe450</code> keelson.TimestampedBytes <code>configuration_json</code> keelson.TimestampedString <code>log_message</code> foxglove.Log <code>sensor_status</code> keelson.SensorStatus <code>network_status</code> keelson.NetworkStatus <code>simulation_status</code> keelson.SimulationStatus <code>roc_status</code> keelson.ROCStatus <code>frame_transform</code> foxglove.FrameTransform <code>location_fix</code> foxglove.LocationFix <code>location_fix_accuracy_horizontal_m</code> keelson.TimestampedFloat <code>location_fix_accuracy_vertical_m</code> keelson.TimestampedFloat <code>location_fix_satellites_used</code> keelson.TimestampedInt <code>location_fix_quality</code> keelson.LocationFixQuality <code>location_fix_hdop</code> keelson.TimestampedFloat <code>location_fix_vdop</code> keelson.TimestampedFloat <code>location_fix_pdop</code> keelson.TimestampedFloat <code>vessel_outline_geojson</code> keelson.TimestampedGeoJSON <code>no_go_zone_geojson</code> keelson.TimestampedGeoJSON <code>navigable_waters_geojson</code> keelson.TimestampedGeoJSON <code>waypoint_geojson</code> keelson.TimestampedGeoJSON <code>rate_of_turn_degpm</code> keelson.TimestampedFloat <code>heading_true_north_deg</code> keelson.TimestampedFloat <code>heading_magnetic_deg</code> keelson.TimestampedFloat <code>course_over_ground_deg</code> keelson.TimestampedFloat <code>speed_over_ground_knots</code> keelson.TimestampedFloat <code>speed_through_water_knots</code> keelson.TimestampedFloat <code>vessel_name</code> keelson.TimestampedString <code>vessel_type</code> keelson.VesselType <code>vessel_imo_number</code> keelson.TimestampedInt <code>vessel_mmsi_number</code> keelson.TimestampedInt <code>vessel_call_sign</code> keelson.TimestampedString <code>vessel_flag_code</code> keelson.FlagCode <code>vessel_nav_status</code> keelson.VesselNavStatus <code>length_over_all_m</code> keelson.TimestampedFloat <code>breadth_over_all_m</code> keelson.TimestampedFloat <code>draught_mean_m</code> keelson.TimestampedFloat <code>draught_max_m</code> keelson.TimestampedFloat <code>draught_stern_m</code> keelson.TimestampedFloat <code>draught_bow_m</code> keelson.TimestampedFloat <code>draught_midship_m</code> keelson.TimestampedFloat <code>wheel_position_pct</code> keelson.TimestampedFloat <code>lever_position_pct</code> keelson.TimestampedFloat <code>propeller_rate_rpm</code> keelson.TimestampedFloat <code>propeller_pitch_pct</code> keelson.TimestampedFloat <code>rudder_angle_deg</code> keelson.TimestampedFloat <code>engine_rate_rpm</code> keelson.TimestampedFloat <code>engine_temperature_celsius</code> keelson.TimestampedFloat <code>engine_fuel_level_pct</code> keelson.TimestampedFloat <code>engine_fuel_rate_lph</code> keelson.TimestampedFloat <code>engine_fuel_consumed_l</code> keelson.TimestampedFloat <code>engine_oil_pressure_psi</code> keelson.TimestampedFloat <code>engine_oil_temperature_celsius</code> keelson.TimestampedFloat <code>engine_coolant_temperature_celsius</code> keelson.TimestampedFloat <code>engine_coolant_pressure_psi</code> keelson.TimestampedFloat <code>battery_type</code> keelson.TimestampedString <code>battery_state_of_charge_pct</code> keelson.TimestampedFloat <code>battery_voltage_volt</code> keelson.TimestampedFloat <code>battery_current_amp</code> keelson.TimestampedFloat <code>battery_temperature_celsius</code> keelson.TimestampedFloat <code>battery_min_voltage_volt</code> keelson.TimestampedFloat <code>battery_max_voltage_volt</code> keelson.TimestampedFloat <code>battery_capacity_amph</code> keelson.TimestampedFloat <code>air_temperature_celsius</code> keelson.TimestampedFloat <code>air_relative_humidity_pct</code> keelson.TimestampedFloat <code>water_temperature_celsius</code> keelson.TimestampedFloat <code>water_salinity_ppt</code> keelson.TimestampedFloat <code>water_speed_of_sound_mps</code> keelson.TimestampedFloat <code>true_wind_direction_deg</code> keelson.TimestampedFloat <code>true_wind_angle_deg</code> keelson.TimestampedFloat <code>true_wind_speed_mps</code> keelson.TimestampedFloat <code>apparent_wind_angle_deg</code> keelson.TimestampedFloat <code>apparent_wind_speed_mps</code> keelson.TimestampedFloat <code>image_raw</code> foxglove.RawImage <code>image_compressed</code> foxglove.CompressedImage <code>video_compressed</code> foxglove.CompressedVideo <code>laser_scan</code> foxglove.LaserScan <code>point_cloud</code> foxglove.PointCloud <code>alarm</code> keelson.Alarm <code>audio</code> keelson.Audio <code>imu_reading</code> keelson.ImuReading <code>radar_spoke</code> keelson.RadarSpoke <code>radar_sweep</code> keelson.RadarSweep <code>target_type</code> keelson.TargetType <code>target_bearing_magnetic_deg</code> keelson.TimestampedFloat <code>target_bearing_north_deg</code> keelson.TimestampedFloat <code>target_bearing_relative_deg</code> keelson.TimestampedFloat <code>target_cpa_m</code> keelson.TimestampedFloat <code>target_tcpa_s</code> keelson.TimestampedFloat <code>target_bcr_m</code> keelson.TimestampedFloat <code>target_bct_s</code> keelson.TimestampedFloat"}]}